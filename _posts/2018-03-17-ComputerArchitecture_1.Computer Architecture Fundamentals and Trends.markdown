---
layout: post
title:  "Computer Architecture&nbsp;1.&nbsp;Fundamentals and Trends"
date:   2018-03-07 21:28:15 +0700
categories: [ComputerArchitecture]
---
#### IT 기술의 발전사

크게 두가지 측면에서 살펴 볼 수 있음

1. 컴퓨터 paradigm - 컴퓨터를 활용하는 방식
2. Technology 발전 

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.1.PNG)

##### 컴퓨터 paradigm 관점

**Mainframe Computing**

처음 컴퓨터 활용 방식은 커다란 컴퓨터를 하나에 여러 유저가 공유하던 시절(당시 최고 회사는 IBM)

1:N

**PC Computing**

나도 개인적인 프로그램, 자료를 갖고 싶은 니즈가 생기고 PC 컴퓨팅 시대가 열림
엄청난 PC 회사들이 생겼고 이런 춘추전국시대를 통합하기위해 IBM이 MS와 Intel과 손을 잡고 PC 시장 호환 규정(표준)이 나오기 시작

1:1

**Internet & Communication**

인터넷 사용이 폭발적으로 증가 -> Communication도 증가

유비쿼터스 시작 포인트(최고의 기업은 시스코)

N:1

**Mobile Computing**

이후 잡스의 APPLE 모바일 Computing을 선보임

**Intelligent Computing**

최근 Big data, Cloud, ML 등이 주도
-> Apple, Google, Amazon이 시당을 주조

##### Technology 발전 관점

IC 역사를 보면 크게 3~4가지 기술적인 진보가 있었음

**Computing power**

IC 성능 개선에 의한 Computing 성능 개선

실리콘벨리 붐으로 성능 개선이 주 목적이였음

**Internet**

유저간의 커뮤니케이션을 시리얼 통신으로 해보니 재미있어 여러가지 활용방법을 제시하면서 붐이 일어남(닷컴 회사)

**침체기**

잠시 침체기에 있다가 다시 동력을 찾은 것이 유비쿼터스임
computing을 모든 영역에 확장해보자

**Smart Devices**

유비쿼터스의 basic을 통해 모든 object에 확장해서 smart한 기계와 어플리케이션을 지능적으로 가동시키는 시대임

수십년간 IT가 시대를 지배하는 시대에 살고 있음



#### First Driving Force on IT History

Computing power 는 2000년대 까지 현대 IT 기술의 발전을 주도함

성능의 발전을 추구함

성능의 비약적인 발전으로 년마다 컴퓨터를 교체해야했음

IC 침 성능뿐만 아니라 시스템 구성이나 OS, Algorithm, 데이터 구조 등 성능을 좋게하기 위한 연구들이 폭발적으로 증가함

이후 실리콘 버블로 많은 회사들이 사라지며 다소 침체기로 넘어감


#### Why Such a Change in CT/IT World?

이전에는 성능이 문제였는데 어느 시점부터 충분한 computing 파워를 제공하기됨 = Real-time 요구사항이 충족되기 시작함

인터넷을 통해 computing resource 를 활용하는 방법을 바꾸어 나가기 시작

인터넷으로 모든 것을 엮어서 구동하므로 개인적으로 좋은 컴퓨터나 리소스를 원하는데로 활용할 수 있는 시절이 도래함

#### Second Driving Force on IT Boost-up

인터넷은 최초 커뮤티케이션이였는데 이후 정보 영토들이 엄청 늘어남

닷컴붐이 일어나고 이때 부터 정보를 생성, 관리, 사용하는 방법을 바꾸기 시작함(Google, Yahoo, Amazon, Facebook 이 남아있음)

이제 성능도 얻었고, 정보(리소스)도 충분해져서 다시 컴퓨터 공학이 슬럼프 기간으로 들어가기 시작함

뭘 해야되는지 모르는 문제에 봉착함 -> 주변을 두리번 거림


#### Impact on IT World

닷컴 버블 이후 이슈들이 없어짐

os도 잘하고 있고, 메모리 공간도 많아 데이터 구조 뭐 중요해... 알고리즘도 컴퓨터 빠른데...

그냥 잘 돌아가고 있는데 하는 상황이 빠짐

주변은 어떻게 돌아가는지 두리번 거리면서 봤더니 ? 

컴퓨터는 비약적인 발전을 했는데 자동차는 아직도 기계덩어리고, 건물은 콘크리트 덩어리였음

여기다 IT 기술을 적용시켜서 지능적으로 만들려니까 일이 많아짐

의도적으로 열심히 찾은 10대 성장 기술을 정의함(홈네트워크, 텔리메틱스 등등 -> 유비쿼터스의 기본 영역)

결국 근본은 유비쿼터스 computing임

-> IT를 모든 영역에 적용을 시키자!

이것이 확장된 것이 IOT 등으로 진화됨


#### Third Movement of IT World

SW, HW 적용을 생각하여 IT 기술을 모든 영역에 적용시켜 지능, 자동적으로 유기적으로 구동할 수 있는 구동환경을 추구함

#### IT Adaptation Strategy

**HW adaptation**

모든 Object에 컴퓨터 엔진을 임베디드 시켜 자동으로 돌아가는 것을 생각해 System On Chip, IoT 등으로 정의함

우리눈에는 보이지 않는 Transparent systems임

**SW adaptation**

알아서 돌아가도록 autonomous 를 추가하기 시작


#### Continuing Movement of IT World

최근은 머신러닝

제어 관리는 배워서 하면 된다는 것임

어떻게 교육을 잘 시키면 내 목적에 잘 맞게 쓸 수 있을까? 가 핵심

모든 영역에서 ML을 이용하려고함

키보드와 마우스를 없애고 싶은 니즈도 결국엔 다 될 것임

IoT - 모든 object에 센서를 다니까 데이터들이 엄청 생성되고 이 전체를 다시 활용하는 방법을 고민한 것이 Big Data

이런 데이터를 분석해서 예측하고 자동화하는 기술들이 들어가고 있음


#### Summary of Recent IT Trend

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.2.PNG)

---

#### Computer Architecture to Focus

트랜드에 맞게 Computer Architecture는 무엇을 해야하는가?

이런 트랜드에서도 컴퓨터 시스템이 핵심임

광범위하게 활용되는 **기본 core engine이 필요** -> 데스크탑이나 여러 시스템에 사용되는 기본 구조

+

어떤 특정영역에 **special한 구조를 활용해보는 엔진** 필요

GP-GPU -> 그래픽스 데이터 병렬화를 위해 구성한 special 엔진

기본 엔진 + special한 구조를 하이브리드로 활용가능

#### Factors to Consider Designing System

설계를 하기 위해 트랜드를 인지해야함

- system / markent/ application trend
- Technology trends도 반영시켜 processor, memory 등에 반영해야 오래 지속되는 모델을 만들 수 있음
- 아키텍쳐도 pipelined, parallelism, hybrid

디자인, 평가 기법들도 살펴야함

#### System Classification

여러 시스템이 존재했지만 현재까지 살아남은 시스템을 아래와 같이 분류할 수 있음

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.3.PNG)

cost를 가지고 군을 나누게됨(경계가 ambiguous함)

#### System Trend

hign end / low end systems 크게 두가지로 군을 구분할 수 있음

이런 시스템 군들은 기술적으로 어떠한 발전 양상을 보였는지 살펴봄

high end system은 매년 35%, low end system은 매년 40 ~ 50% 향상을 보여줌
-> 위의 말은 조만간 나의 Personal Mobile Device에 완전한 supercomputing power가 장착된다는 것임

기존의 여러 시스템(Main frame, SC)는 사라질 것임

#### System Running Environment

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.4.PNG)

####  Technology Change in Recent 20 years

이러한 성능의 개선은 기술적인 진보와 구조적인 진보를 통해 이루어져 왔음

**Performance improvement**

기술적인 진보라고 하는 것은 cost, feature size, clock speed 에서 비용이나 성능적으로 이전 시스템을 제압했고,

구조적으로 시스템 성능개선을 위해 이전 슈퍼컴퓨터에서 사용한 기술을 PC나 모바일에 적용해 비약적인 성능 발전을 이룸

**Cost Down**

대량생산의 극대화 되기 시작했고 컴퓨터 시스템 사이즈가 작아져 component도 적어지면서 빠르게 만들어질 수 있어 제조가격이 내려감

**인터넷에 의한 활용방법의 변화**

위의 3가지가 현재 시스템을 사용하게된 배경으로 작용함

####  Growth in Process Performance

먼저 CPU 성능 변화를 살펴봄

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.5.PNG)

매년 25퍼정도의 성능향상이 있고 이후 급속도로 발전하다가 줄어들면서 최근 들어 천천히 가고 있음


####  Technology Trends: Moore's Law

**모스의 법칙**

IC의 발전을 예측하는 법칙으로 Chip 밀집도(단위 면적의 집적될 수 있는 트렌지스터 개수)가 18개월마다 2배가 된다는 법칙

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.6.PNG)

모든 IC 기술들이 같은 비율로 증가함(메모리나 프로세서나)


####  Technology Trends(Summary)

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.7.PNG)

Logic은 매 3년마다 용량 2배, 스피드도 2배 증가함

그런데 DRAM은 용량은 용량은 4배, 스피드는 2배로 속도에 비해 집적도가 크게 발전함

Flash / DRAM / Disk 비용 cheaper 도 살펴보기

로직 스피드는 DRAM보다 훨씬 빨리 증가하고 있음
-> 반노이만 컴퓨터 구조는 Fetch, Decode Execute 를 무한 반복하는데 명령어를 사용하기위해 메모리로 부터 Fetch 해야하는데 Logic을 빨리해놔도 메모리에 종속되어서 움직일 수 밖에 없음

프로세스와 메모리간의 속도 격차를 Memory wall problem으로 정의


####  Latency Lags Bandwidth in 20 years

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.8.PNG)

Latency는 Bandwidth 보다 서서히 개선되는 경향이 있음

Bandwidth가 두배 뛸때 latency는 1.2배나 1.4배 증가하는 경향이 있음

Latency는 response time이고 Bandwidth(throughput)는 주어진 시간에 한 일의 양으로 보면됨

####  P-M Performance Gap

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.9.PNG)

시간이 갈수록 Gap이 커짐

성능해소를 위해 **캐시**를 설계하여 두개의 격차를 완화하려함

메모리를 계층으로 설계하는 배경 - 사용자에게 아주 고속의 메모리, 밑의 계층에는 많은 용량이 있는 것 같은 체감 효과를 주기위한 설계임

이렇게 빠른 메모리가 이렇게 많이 있어 하는 트릭을 주는 것

Memory - Disk : Virtual Memory 시스템(OS가 함)

Cache-Memory : 캐쉬 메모리 시스템(전부 하드웨어 제어로 transparent 한 구조임)

####  System Performance Trends(Summary)

Performance 만 이야기할 수 없고 Cost도 봐야함(돈 얼마 썼는데 얼마 얻는 것을 봐야함)

모든 컴포넌트를 보편적으로 가지고 있는 시스템이 Destop 시스템이고 이걸 가지고 성능 관점의 패턴 조사시 매년 50% (18개월 마다 2배씩 - 무어의 법칙) 증가함 -> 기술자체만으로도 이정도 증가 시킴

cost /performance 관점에서는 매년 70% 증가함?

performance 자체는 돈 쓴 만큼 얻지만 cost를 따지면서 보면 어떤 설계에 있어서 창의적인 방법을 마구 적용해 100원 썼는데 150원 가치를 얻어내는 방법들을 많이 가져다 쓴 것을 의미함

---

####  Power and Energy

모바일 디바이스로 인해 파워소모도 상당한 문제를 가짐

측정에 있어 TDP(Thermal Design Power)를 쓰고 일정한 파워 소모를 측정함

이 값을 통해 파워서플라이나 쿨링시스템을 준비하는데 가이드라인이 됨

peak power 보다는 낮게, 평균 파워소비보다는 높게 셋팅함

Power Energy를 절약하는 칩적인 방법은 dynamic frequency scaling 기법으로 clock wait를 조절해 파워 소모를 조절함

####  Dynamic Power and Energy

**Dynamic Energy**

트랜지스터가 0<->1로 바뀔 때 소모하는 에너지

**Dynamic Power**

Dynamic Energy에 frequency를 곱해주면 구할 수 있음

Clock rate를 줄이면 energy는 줄일 수 없지만 power는 줄일 수 있음

####  Power Consumption

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.10.PNG)

이 그래프의 Y는 frequency임
X축은 연도

2W -> 130W 소모 증가함

CPU 면적은 1.5*1.5 공간이 있는데, 뚜껑에 팬을 걸어놓고 돌려 강제 쿨다운 시키는데 이 것을 할 수 있는 최대 값이 3.3GHZ임

3.GHZ 까지가 에어쿨링으로 열을 조절할 수 있는 분기점임

이때 부터는 water 쿨링이 필요함 -> 쓸 수 없음

CPU하나의 성능증가는 물리적인 한계에 도달했고, 따라서 여러 개 쓰는 작업을 하기 시작함(멀티코어)


####  System Design Trends in Architecture

하나의 CPU 개선하는것은 2003년에 끝남

성능증가를 위해 DLP, TLP, RLP 등장

DLP(Data-level parallelism) 여러데이터 한번에

TLP(Thread-level parallelism) 여러 스레드

최대 성능을 얻기위해 응용프로그램 재구성해야함


####  Parallelism in Architecture

- Classes of parallelism in applications : DLP, TLP
- Classes of architectural parallelism : ILP(Instruction-Level Parallelism), GPUS(Vector architectures/Graphic Processor Units), TLP, RLP(Request-Level Parallelism)

####  Flynn's Taxonomy

아키텍처 모델은 어떤 것들이 있는지 stream으로 구분

명령과 데이터 stream으로 구분

SISD : 하나씩(Single instruction stream, single data stream)

SIMD : 한 개의 프로그램에 여러 개의 데이터가 동시에 적용됨(vector, SIMD, GPU 베이스 엔진이 이렇게 생김)

MISD는 없다

MIMD : 명령어도여러 개 데이터도 여러 개	-> 보편적 머신(프로세서간 통신 필요)

- Tightly Loosely 존재
- 프로세서와 메모리가 여러 개 있는데 여러 개의 프로세서간에 같이 일하려면 일을 쪼개 나눠서 수행하고 나중에 수행결과 취합한 결과가 필요
- Tightly에서는 한 개의 signle memory 공유하도록 되어있음(여러 개의 프로세서)
- Loosely는 코어당 독립적인 memory 존재

---

####  Taxonomical System Design Goal

시스템 설계 어떤 것이 ideal?

이상적인 목표는 프로세서 수를 증대 시키면 거기에 상응하게 Perfomance도 linear 하게 증가하는 것임

이게 이상적인 것은 아님

그래야 필요한 양은 제한되고 용도에 따라 맞게 써야함

####  Architectural Design

최근 설계 정의 - 다양한 기능을 선정하여 하나의 시스템으로 컴포넌트들을 재구성하는 것을 설계라고 함

모든 측면에서 균형이잡힌 시스템을 설계하면 좋은 설계임

**balanced system?**

Case & Amdahl 관점에서 시작하면 balanced 함

1 MIPS 는 1MBs 메모리와 1Mbit IO로 구성하면 balanced라고 얘기할 수 있음

다른 모듈이 기다리는 delay를 없게하는 것


####  Measurement and Evaluation

설계한 것을 평가하는 것은

성능 - 100원 넣고 200원 나온 것이 good ideas임

Cost 가 어떤지를 얘기함

####  Cost / Performance Effect

돈을 쓴 만큼 성능 개선됨

![Alt text](http://leesangwon0114.github.io/static/img/CA/1.11.PNG)

주어진 tech 1 에서 성능을 얻기위해 constant 하다가 더 이상 성능 안올라가면 tech2 새로 발전

####  Quantitative Principles of Computer Design

지금부터 설계를 어떻게 해야할까?

3가지 기본 원칙을 사용함

	1. 병렬성을 이용해라
	단순하면서도 전통적으로 써먹음
	Instruction, process, task에 마구 활용함

	2. 지역성을 이용
	프로그램의 수행 특성을 가지고 캐쉬메모리를 설계함
	프로그램의 어떤 특성?
	프로그램이 100이라하면 10%가 루프인데 여기서 전체 수행시간의 90%가 여기에 발생함
	-> 이 수행 특성을 활용하는 것을 사용자에게 제공
	Cache를 10% 주고 Memory를 90% 로 넣고 돌리면 90% 빨리돌아가네 하는 느낌을 준다

    locality
	주소의 특정 부분만 반복적으로 수행하는 특성이 있음
	시간(loops, reuse), 공간적(straightline code, array access)인 것으로 나뉠 수 있음
	
	3. Common case를 집중해라
	보편적인 곳을 먼저 처리해야함
    가장 많이 사용하는 것을 가장 잘 동작하도록


####  Focus on the Common Case

별로 빈도수가 작은 것 보다 자주 발생하는 곳에 리소스를 투입하라

일반적으로 보면 빈번하게 발생하는 것은 simple한 것이 많음 -> 이것을 빨리 돌아가도록하면 더 빨라질 수 있음

머가 frequenct case인데? 여기에 따라 얼마나 성능효과?
Amdahl's Law가 잘 설명해줌


