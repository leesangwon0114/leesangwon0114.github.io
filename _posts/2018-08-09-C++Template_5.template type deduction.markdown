---
layout: post
title:  "C++Template&nbsp;5.&nbsp;template type deduction"
date:   2018-08-09 04:28:15 +0700
categories: [c++]
---

codenuri 강석민 강사 강의 내용기반으로 정리한 내용입니다.

#### boost::type_index

1. C++ 표준의 typeid() 연산자 사용
 - const, volatile, reference 를 조사할 수 없음
2. boost의 type_index 라이브러리 사용
 - const, volatile, reference 를 조사 할 수 있음

```cpp
#include <iostream>
using namespace std;

template<typename T> void foo(const T a) 
{
    cout << "T : " << typeid(T).name() << endl;
    cout << "a : " << typeid(a).name() << endl;
}

int main()
{
    // foo<int>(3);

    foo(3); // T: int, a: const int
    foo(3.3);   // T: double, a: const double
}
```
출력결과는 모두 int, double 임 -> boost 사용

1. <boost\type_index.hpp>
2. namespace boost::typeindex 안에 있음
3. type_id_with_cvr<T>().pretty_name() 으로 사용
4. 변수의 타입을 조사 할 때는 decltype()을 사용함
 - type_id_with_cvr<decltype(a)>().pretty_name()


```cpp
#include <iostream>
#include <boost\type_index.hpp>
using namespace std;
using namespace boost::typeindex;

template<typename T> void foo(const T a) 
{
    cout << type_id_with_cvr<T>().pretty_name() << endl;
    cout << type_id_with_cvr<decltype(A)>().pretty_name() << endl;
}

int main()
{
    foo(3); // T: int, a: const int
    foo(3.3);   // T: double, a: const double
}
```
출력결과

![Alt text](/static/img/C++/5.1.PNG)